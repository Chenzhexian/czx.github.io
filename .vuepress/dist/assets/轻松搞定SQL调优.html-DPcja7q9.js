import{_ as e,o as l,c as a,e as s}from"./app-CzSBTTj3.js";const n={},i=s(`<h2 id="_1-日常工作怎么进行sql调优的" tabindex="-1"><a class="header-anchor" href="#_1-日常工作怎么进行sql调优的"><span>1.日常工作怎么进行SQL调优的?</span></a></h2><ul><li>分析慢查询日志</li><li>使用explain查看执行计划</li><li>索引优化</li><li>深分页优化</li><li>避免全表扫描</li><li>避免返回不必要的数据（如select具体字段而不是select*）</li><li>使用合适的数据类型（如可以使用int类型的话，就不要设计为varchar）</li><li>优化sql结构（如join优化等等）</li><li>适当分批量进行 (如批量更新、删除)</li><li>定期清理无用的数据</li><li>适当分库分表</li><li>读写分离</li></ul><h2 id="_2-是否遇到过深分页问题-如何解决" tabindex="-1"><a class="header-anchor" href="#_2-是否遇到过深分页问题-如何解决"><span>2.是否遇到过深分页问题，如何解决</span></a></h2><p>我们可以通过减少回表次数来优化。一般有标签记录法和延迟关联法。</p><h3 id="标签记录法" tabindex="-1"><a class="header-anchor" href="#标签记录法"><span>标签记录法</span></a></h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>就是标记一下上次查询到哪一条了，下次再来查的时候，从该条开始往下扫描。就好像看书一样，上次看到哪里了，你就折叠一下或者夹个书签，下次来看的时候，直接就翻到啦。</p></div><p>假设上一次记录到100000，则SQL可以修改为：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span>  id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>balance <span class="token keyword">FROM</span> account <span class="token keyword">where</span> id <span class="token operator">&gt;</span> <span class="token number">100000</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样的话，后面无论翻多少页，性能都会不错的，因为命中了id索引。但是这种方式有局限性：需要一种类似连续自增的字段。</p><h3 id="延迟关联法" tabindex="-1"><a class="header-anchor" href="#延迟关联法"><span>延迟关联法</span></a></h3><p>延迟关联法，就是把条件转移到主键索引树，然后减少回表。假设原生SQL是这样的的，其中<code>id</code>是主键，<code>create_time</code>是普通索引</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>balance <span class="token keyword">from</span> account <span class="token keyword">where</span> create_time<span class="token operator">&gt;</span> <span class="token string">&#39;2020-09-19&#39;</span> <span class="token keyword">limit</span> <span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用延迟关联法优化，如下：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span>  acct1<span class="token punctuation">.</span>id<span class="token punctuation">,</span>acct1<span class="token punctuation">.</span>name<span class="token punctuation">,</span>acct1<span class="token punctuation">.</span>balance <span class="token keyword">FROM</span> account acct1 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> 
<span class="token punctuation">(</span><span class="token keyword">SELECT</span> a<span class="token punctuation">.</span>id <span class="token keyword">FROM</span> account a <span class="token keyword">WHERE</span> a<span class="token punctuation">.</span>create_time <span class="token operator">&gt;</span> <span class="token string">&#39;2020-09-19&#39;</span> <span class="token keyword">limit</span> <span class="token number">100000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> 
<span class="token keyword">AS</span> acct2 <span class="token keyword">on</span> acct1<span class="token punctuation">.</span>id<span class="token operator">=</span> acct2<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优化思路就是，先通过idx_create_time二级索引树查询到满足条件的主键ID，再与原表通过主键ID内连接，这样后面直接走了主键索引了，同时也减少了回表。</p><h2 id="_3-谈谈explain执行计划" tabindex="-1"><a class="header-anchor" href="#_3-谈谈explain执行计划"><span>3.谈谈explain执行计划</span></a></h2><p>当<code>explain</code>与<code>SQL</code>一起使用时，MySQL将显示来自优化器的有关语句执行计划的信息。即<code>MySQL</code>解释了它将如何处理该语句，包括有关如何连接表以及以何种顺序连接表等信息。</p><p>一条简单SQL，使用了<code>explain</code>的效果如下：</p><p><img src="https://czxcab.cn/file/docs/sqloptimize1.jpg" alt=""></p><p>一般来说，我们需要重点关注<code>type、rows、filtered、extra、key</code>。</p><h3 id="_3-1-type" tabindex="-1"><a class="header-anchor" href="#_3-1-type"><span>3.1 type</span></a></h3><p>type表示连接类型，查看索引执行情况的一个重要指标。以下性能从好到坏依次：<code>system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code></p><ul><li><code>system</code>：这种类型要求数据库表中只有一条数据，是<code>const</code>类型的一个特例，一般情况下是不会出现的。</li><li><code>const</code>：通过一次索引就能找到数据，一般用于主键或唯一索引作为条件，这类扫描效率极高，速度非常快。</li><li><code>eq_ref</code>：常用于主键或唯一索引扫描，一般指使用主键的关联查询</li><li><code>ref</code> : 常用于非主键和唯一索引扫描。</li><li><code>ref_or_null</code>：这种连接类型类似于<code>ref</code>，区别在于MySQL会额外搜索包含<code>NULL</code>值的行</li><li><code>index_merge</code>：使用了索引合并优化方法，查询使用了两个以上的索引。</li><li><code>unique_subquery</code>：类似于<code>eq_ref</code>，条件用了<code>in</code>子查询</li><li><code>index_subquery</code>：区别于<code>unique_subquery</code>，用于非唯一索引，可以返回重复值。</li><li><code>range</code>：常用于范围查询，比如：between ... and 或 In 等操作</li><li><code>index</code>：全索引扫描</li><li><code>ALL</code>：全表扫描</li></ul><h3 id="_3-2-rows" tabindex="-1"><a class="header-anchor" href="#_3-2-rows"><span>3.2 rows</span></a></h3><p>该列表示MySQL估算要找到我们所需的记录，需要读取的行数。对于InnoDB表，此数字是估计值，并非一定是个准确值。</p><h3 id="_3-3-filtered" tabindex="-1"><a class="header-anchor" href="#_3-3-filtered"><span>3.3 filtered</span></a></h3><p>该列是一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。</p><h3 id="_3-4-extra" tabindex="-1"><a class="header-anchor" href="#_3-4-extra"><span>3.4 extra</span></a></h3><p>该字段包含有关MySQL如何解析查询的其他信息，它一般会出现这几个值：</p><ul><li><code>Using filesort</code>：表示按文件排序，一般是在指定的排序和索引排序不一致的情况才会出现。一般见于order by语句</li><li><code>Using index</code> ：表示是否用了覆盖索引。</li><li><code>Using temporary</code>: 表示是否使用了临时表,性能特别差，需要重点优化。一般多见于group by语句，或者union语句。</li><li><code>Using where</code> : 表示使用了where条件过滤.</li><li><code>Using index condition</code>：MySQL5.6之后新增的索引下推。在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</li></ul><h3 id="_3-5-key" tabindex="-1"><a class="header-anchor" href="#_3-5-key"><span>3.5 key</span></a></h3><p>该列表示实际用到的索引。一般配合<code>possible_keys</code>列一起看。</p><p><strong>注意</strong>:有时候，<code>explain</code>配合<code>show WARNINGS</code>; （可以查看优化后,最终执行的sql），效果更佳哦。</p><h2 id="_4-说说大表的优化方案" tabindex="-1"><a class="header-anchor" href="#_4-说说大表的优化方案"><span>4.说说大表的优化方案</span></a></h2><p><img src="https://czxcab.cn/file/docs/sqloptimize2.jpg" alt=""></p><h3 id="数据库设计优化" tabindex="-1"><a class="header-anchor" href="#数据库设计优化"><span>数据库设计优化</span></a></h3><p>合理的数据库设计可以极大地提高查询效率。我们在设计大表时，可以考虑<strong>拆分表、使用分区表、添加索引等方式</strong>来优化表结构。同时也要<strong>避免使用大量冗余字段、避免频繁使用join查询等</strong>操作。</p><h3 id="索引优化" tabindex="-1"><a class="header-anchor" href="#索引优化"><span>索引优化</span></a></h3><p>对于大表的查询操作，索引优化是非常重要的一环。可以考虑增加或者修改索引、使用覆盖索引、使用联合索引等方式来提高查询效率。同时也要注意定期清理冗余的索引以及对于经常使用的查询语句建立索引。</p><h3 id="分区优化" tabindex="-1"><a class="header-anchor" href="#分区优化"><span>分区优化</span></a></h3><p>将大表按照某个列分成多个分区表，每个分区表的数据量较小，可以提高查询和更新的性能。分区表还可以帮助在维护表结构的同时，减少锁表时间，提高并发处理能力。</p><h3 id="数据清理归档" tabindex="-1"><a class="header-anchor" href="#数据清理归档"><span>数据清理归档</span></a></h3><p>对于一些历史数据或者无用数据，可以进行定期归档，避免数据过多造成SQL查询效率降低。同时也要注意对于大表进行定期的数据备份以及紧急数据恢复的准备工作。</p><h3 id="缓存优化" tabindex="-1"><a class="header-anchor" href="#缓存优化"><span>缓存优化</span></a></h3><p>对于一些经常被查询的数据，可以使用缓存优化。使用<code>Redis</code>等缓存中间件来缓存常用的数据，以减少查询数据库的次数，提高查询效率。</p><h3 id="sql语句优化" tabindex="-1"><a class="header-anchor" href="#sql语句优化"><span>SQL语句优化</span></a></h3><p>在编写SQL查询语句时，要尽可能地简单明了，避免复杂的查询语句，同时也要避免一些不必要的查询操作。对于复杂的查询语句，可以使用<code>Explain</code>执行计划来进行优化。同时也要注意避免使用<code>OR</code>等耗费性能的操作符。</p><h3 id="分库分表" tabindex="-1"><a class="header-anchor" href="#分库分表"><span>分库分表</span></a></h3><p>如果数据量千万级别，需要考虑分库分表哈。</p><h2 id="_5-哪些因素可能导致mysql慢查询" tabindex="-1"><a class="header-anchor" href="#_5-哪些因素可能导致mysql慢查询"><span>5.哪些因素可能导致MySQL慢查询？</span></a></h2><ul><li>慢查询一般有以下这些原因：</li><li>SQL没加索引</li><li>SQL 索引不生效</li><li>limit深分页问题</li><li>单表数据量太大</li><li>join 或者子查询过多</li><li>in元素过多</li><li>数据库在刷脏页</li><li>order by 走文件排序</li><li>拿不到锁</li><li>delete + in子查询不走索引</li><li>group by使用临时表和文件排序</li><li>系统或网络资源不够</li></ul><h2 id="_6-如何使用索引优化sql查询" tabindex="-1"><a class="header-anchor" href="#_6-如何使用索引优化sql查询"><span>6.如何使用索引优化SQL查询？</span></a></h2><p><img src="https://czxcab.cn/file/docs/sqloptimize3.jpg" alt=""></p><ul><li>添加合适索引（在<code>where、group by、order by</code>等后面的字段添加合适索引）</li><li>选择合适的索引类型 (<code>B-tree</code>索引适合范围查询、哈希索引适合等值查询)</li><li>注意不适合加索引的场景（数据量少的表，更新频繁的字段，区分度低的字段）</li><li>加索引的时候，需要考虑覆盖索引，减少回表，考虑联合索引的最左前缀原则</li><li><code>explain</code>查看SQL的执行计划，确认是否会命中索引。</li><li>注意索引并不是越多越好，<strong>通常建议在单个表中不要超过5个索引</strong>。因为索引会占用磁盘空间，索引更新代价高。</li></ul><h2 id="_7-聊聊慢sql的优化思路" tabindex="-1"><a class="header-anchor" href="#_7-聊聊慢sql的优化思路"><span>7.聊聊慢SQL的优化思路</span></a></h2><ol><li>查看慢查询日志记录，分析慢SQL</li><li>explain分析SQL的执行计划</li><li>profile 分析执行耗时</li><li>Optimizer Trace分析详情</li><li>确定问题并采用相应的措施</li></ol><h3 id="_7-1-查看慢查询日志记录-分析慢sql" tabindex="-1"><a class="header-anchor" href="#_7-1-查看慢查询日志记录-分析慢sql"><span>7.1 查看慢查询日志记录，分析慢SQL</span></a></h3><p>如何定位慢SQL呢、我们可以通过slow log来查看慢SQL。默认的情况下呢，MySQL数据库是不开启慢查询日志（slow query log）呢。所以我们需要手动把它打开。</p><p>查看下慢查询日志配置，我们可以使用 <code>show variables like &#39;slow_query_log%&#39;</code> 命令，如下：</p><p><img src="https://czxcab.cn/file/docs/sqloptimize4.jpg" alt=""></p><ul><li><code>slow query log</code>表示慢查询开启的状态</li><li><code>slow_query_log_file</code>表示慢查询日志存放的位置</li></ul><p>怎么开启慢查询记录呢，我们可以在<code>my.cnf</code>配置文件中，添加如下配置：</p><div class="language-properties line-numbers-mode" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="token key attr-name">slow_query_log</span> <span class="token punctuation">=</span> <span class="token value attr-value">1</span>
<span class="token key attr-name">slow_query_log_file</span> <span class="token punctuation">=</span> <span class="token value attr-value">/var/lib/mysql/mysql-slow.log</span>
<span class="token comment"># 超过1秒就是慢查询</span>
<span class="token key attr-name">long_query_time</span> <span class="token punctuation">=</span> <span class="token value attr-value">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还可以使用 <code>show variables like &#39;long_query_time&#39;</code> 命令，查看超过多少时间，才记录到慢查询日志，如下：</p><p><img src="https://czxcab.cn/file/docs/sqloptimize5.jpg" alt=""></p><ul><li>long_query_time表示查询超过多少秒才记录到慢查询日志。</li></ul><p><strong>我们可以通过慢查日志，定位那些执行效率较低的SQL语句，重点关注分析。</strong></p><h3 id="_7-2-explain查看分析sql的执行计划" tabindex="-1"><a class="header-anchor" href="#_7-2-explain查看分析sql的执行计划"><span>7.2 explain查看分析SQL的执行计划</span></a></h3><p>当定位出查询效率低的SQL后，可以使用<code>explain</code>查看SQL的执行计划。</p><p>这个上面也有讲到了 <a href="#_3-%E8%B0%88%E8%B0%88explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92">explain执行计划</a></p><h3 id="_7-3-profile分析执行耗时" tabindex="-1"><a class="header-anchor" href="#_7-3-profile分析执行耗时"><span>7.3 profile分析执行耗时</span></a></h3><p><code>explain</code>只是看到SQL的预估执行计划，如果要了解SQL真正的执行线程状态及消耗的时间，需要使用<code>profiling</code>。开启<code>profiling</code>参数后，后续执行的SQL语句都会记录其资源开销，包括IO，上下文切换，CPU，内存等等，我们可以根据这些开销进一步分析当前慢SQL的瓶颈再进一步进行优化。</p><p><code>profiling</code>默认是关闭，我们可以使用<code>show variables like &#39;%profil%&#39;</code>查看是否开启，如下：</p><p><img src="https://czxcab.cn/file/docs/sqloptimize6.jpg" alt=""></p><p>可以使用<code>set profiling=ON</code>开启。开启后，可以运行几条SQL，然后使用<code>show profiles</code>查看一下。</p><p><img src="https://czxcab.cn/file/docs/sqloptimize7.jpg" alt=""></p><p><code>show profiles</code>会显示最近发给服务器的多条语句，条数由变量<code>profiling_history_size</code>定义，默认是15。如果我们需要看单独某条SQL的分析，可以<code>show profile</code>查看最近一条SQL的分析。也可以使用<code>show profile for query id</code>（其中id就是<code>show profiles</code>中的<code>QUERY_ID</code>）查看具体一条的SQL语句分析。</p><h3 id="_7-4-optimizer-trace分析详情" tabindex="-1"><a class="header-anchor" href="#_7-4-optimizer-trace分析详情"><span>7.4 Optimizer Trace分析详情</span></a></h3><p><code>profile</code>只能查看到SQL的执行耗时，但是无法看到SQL真正执行的过程信息，即不知道MySQL优化器是如何选择执行计划。这时候，我们可以使用<code>Optimizer Trace</code>，它可以跟踪执行语句的解析优化执行的全过程。</p><p>我们可以使用<code>set optimizer_trace=&quot;enabled=on&quot;</code>打开开关，接着执行要跟踪的SQL，最后执行<code>select * from information_schema.optimizer_trace</code>跟踪。</p><p>大家可以查看分析其执行树，会包括三个阶段：</p><ul><li>join_preparation：准备阶段</li><li>join_optimization：分析阶段</li><li>join_execution：执行阶段</li></ul><h3 id="_7-5-确定问题并采用相应的措施" tabindex="-1"><a class="header-anchor" href="#_7-5-确定问题并采用相应的措施"><span>7.5 确定问题并采用相应的措施</span></a></h3><p>最后确认问题，就采取对应的措施。</p><ul><li>多数慢SQL都跟索引有关，比如不加索引，索引不生效、不合理等，这时候，我们可以优化索引。</li><li>我们还可以优化SQL语句，比如一些in元素过多问题（分批），深分页问题（基于上一次数据过滤等），进行时间分段查询</li><li>SQl没办法很好优化，可以改用ES的方式，或者数仓。</li><li>如果单表数据量过大导致慢查询，则可以考虑分库分表</li><li>如果数据库在刷脏页导致慢查询，考虑是否可以优化一些参数，跟DBA讨论优化方案</li><li>如果存量数据量太大，考虑是否可以让部分数据归档</li></ul><h2 id="_8-一条sql执行过长的时间-你如何优化-从哪些方面入手" tabindex="-1"><a class="header-anchor" href="#_8-一条sql执行过长的时间-你如何优化-从哪些方面入手"><span>8.一条sql执行过长的时间，你如何优化，从哪些方面入手？</span></a></h2><ul><li>确定瓶颈</li><li>索引优化</li><li>优化SQL语句</li><li>数据库参数优化</li><li>分析锁的情况</li><li>数据库硬件升级</li></ul><h3 id="确定瓶颈" tabindex="-1"><a class="header-anchor" href="#确定瓶颈"><span>确定瓶颈</span></a></h3><p>首先，通过查看MySQL日志，慢查询日志，explain分析SQL的执行计划，profile 分析执行耗时，Optimizer Trace分析详情等操作，确定查询执行的瓶颈在哪里。只有确定了瓶颈，才能有针对性地进行优化。</p><h3 id="索引优化-1" tabindex="-1"><a class="header-anchor" href="#索引优化-1"><span>索引优化</span></a></h3><p>在确定了瓶颈之后，可以考虑通过增加索引来优化查询效率。可以根据查询语句的条件，增加相应的索引，从而加快查询速度。但是索引也会带来一些负面影响，如占用磁盘空间，降低写入效率等，所以需要根据具体情况权衡。</p><h3 id="优化sql语句" tabindex="-1"><a class="header-anchor" href="#优化sql语句"><span>优化SQL语句</span></a></h3><p>有些SQL语句本身可能存在一些问题，如join操作过于频繁，使用了不必要的子查询等，这些都会导致查询效率低下。可以通过优化SQL语句来减少不必要的操作，从而提高查询效率。</p><h3 id="数据库参数优化" tabindex="-1"><a class="header-anchor" href="#数据库参数优化"><span>数据库参数优化</span></a></h3><p>数据库参数也会影响查询效率，可以通过修改数据库参数来优化查询效率，如修改内存缓存大小、修改连接池大小等。不同的数据库参数优化方式不同，需要根据具体情况进行调整。</p><h3 id="分析锁的情况" tabindex="-1"><a class="header-anchor" href="#分析锁的情况"><span>分析锁的情况</span></a></h3><p>查询执行时间过长有可能是由于锁的问题导致的，需要分析查询语句中是否存在锁的问题，如果存在锁的问题，可以考虑增加锁的并发度，从而提高查询效率。</p><h3 id="数据库硬件升级" tabindex="-1"><a class="header-anchor" href="#数据库硬件升级"><span>数据库硬件升级</span></a></h3><p>如果以上方法都无法解决问题，可以考虑对数据库硬件进行升级，如增加 CPU 数量、加快磁盘读写速度等，从而提高数据库的整体性能。</p><h2 id="_9-列举一下-常用的数据库设计优化技巧" tabindex="-1"><a class="header-anchor" href="#_9-列举一下-常用的数据库设计优化技巧"><span>9.列举一下，常用的数据库设计优化技巧？</span></a></h2><ul><li>字段尽量避免使用NULL</li><li>合理选择数据类型</li><li>字段选择合适的长度</li><li>正确使用索引</li><li>尽量少定义text类型</li><li>合理的数据表结构设计</li><li>适当的冗余设计</li><li>优化SQL查询语句</li><li>一张表的字段不宜过多</li></ul><h2 id="_10-列举日常开发中-列举十个书写高质量sql的小技巧" tabindex="-1"><a class="header-anchor" href="#_10-列举日常开发中-列举十个书写高质量sql的小技巧"><span>10.列举日常开发中，列举十个书写高质量SQL的小技巧</span></a></h2><ul><li>查询SQL尽量不要使用select *，而是select具体字段。</li><li>小表驱动大表</li><li>优化你的like语句</li><li>尽量避免在索引列上使用mysql的内置函数</li><li>如果插入数据过多，考虑批量操作。</li><li>多用limit</li><li>小表驱动大表</li><li>exist &amp; in合理利用</li><li>in元素不要过多</li><li>尽量用union all替换union</li></ul><h2 id="_11-index-merge了解过嘛" tabindex="-1"><a class="header-anchor" href="#_11-index-merge了解过嘛"><span>11.index merge了解过嘛？</span></a></h2><p>index merge是什么？</p><blockquote><p>在MySQL中，当执行一个查询语句需要使用多个索引时，MySQL可以使用索引合并(Index Merge)来优化查询性能。具体来说，索引合并是将多个单列索引或多个联合索引合并使用，以满足查询语句的需要。</p></blockquote><p>当使用索引合并时，MySQL会选择最优的索引组合来执行查询，<strong>从而避免了全表扫描和排序操作，提高了查询效率</strong>。而对于使用多个单列索引的查询语句，MySQL也可以使用索引合并来优化查询性能。</p><p>大家可以看一个使用<code>index merge</code>的例子：</p><p>假设有一个名为<code>orders</code>的表，包含<code>order_id、customer_id、product_id、order_date</code>等字段，其中<code>order_id、customer_id、product_id</code>三个字段都建有索引。</p><p>如果要查询<code>customer_id</code>为<code>1</code>，<code>order_date</code>在2022年1月1日到2022年2月1日之间的订单记录，可以使用以下SQL语句：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> orders
<span class="token keyword">WHERE</span> customer_id <span class="token operator">=</span> <span class="token number">1</span>
<span class="token operator">AND</span> order_date <span class="token operator">&gt;=</span> <span class="token string">&#39;2022-01-01&#39;</span>
<span class="token operator">AND</span> order_date <span class="token operator">&lt;</span> <span class="token string">&#39;2022-02-01&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在执行该查询语句时，MySQL可以使用<code>customer_id</code>索引和<code>order_date</code>索引来优化查询。如果使用单个索引，则需要扫描整个索引树来匹配查询条件；但如果使用索引合并，则可以先使用<code>customer_id</code>索引来过滤出符合条件的记录，然后再使用<code>order_date</code>索引来进一步过滤记录，从而大大减少了扫描的记录数，提高了查询效率。</p><p>大家可以使用<code>EXPLAIN</code>关键字可以查看查询计划，确认是否使用了索引合并。例如，执行以下语句：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> orders
<span class="token keyword">WHERE</span> customer_id <span class="token operator">=</span> <span class="token number">1</span>
<span class="token operator">AND</span> order_date <span class="token operator">&gt;=</span> <span class="token string">&#39;2022-01-01&#39;</span>
<span class="token operator">AND</span> order_date <span class="token operator">&lt;</span> <span class="token string">&#39;2022-02-01&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果查询计划中出现了Using index merge的信息，则表示该查询使用了索引合并优化。</p><h2 id="_12-order-by查询效率慢-如何优化" tabindex="-1"><a class="header-anchor" href="#_12-order-by查询效率慢-如何优化"><span>12. order by查询效率慢,如何优化？</span></a></h2><p><code>order by</code>查询为什么会慢嘛?</p><p><code>order by</code>排序，分为全字段排序和<code>rowid</code>排序。它是拿<code>max_length_for_sort_data</code>和结果行数据长度对比，如果结果行数据长度超过<code>max_length_for_sort_data</code>这个值，就会走<code>rowid</code>排序，相反，则走全字段排序。</p><p><code>rowid</code>排序，一般需要回表去找满足条件的数据，所以效率会慢一点.如果是<code>order by</code>排序,可能会借助磁盘文件排序的话，效率就更慢一点.</p><p>如何优化<code>order by</code>的文件排序?</p><ul><li>因为数据是无序的，所以就需要排序。如果数据本身是有序的，那就不会再用到文件排序啦。而索引数据本身是有序的，我们通过建立索引来优化<code>order by</code>语句。</li><li>我们还可以通过调整<code>max_length_for_sort_data、sort_buffer_size</code>等参数优化。</li></ul><h2 id="_13-group-by-查询慢的话-如何优化" tabindex="-1"><a class="header-anchor" href="#_13-group-by-查询慢的话-如何优化"><span>13. group by 查询慢的话,如何优化?</span></a></h2><p><code>group by</code>一般用于分组统计，它表达的逻辑就是根据一定的规则，进行分组。日常开发中，我们使用得比较频繁。如果不注意，很容易产生慢SQL。</p><p><code>group by</code>可能会慢在哪里？因为它既用到临时表，又默认用到排序。有时候还可能用到磁盘临时表。</p><ul><li>如果执行过程中，会发现内存临时表大小到达了上限（控制这个上限的参数就是<code>tmp_table_size</code>），会把内存临时表转成磁盘临时表。</li><li>如果数据量很大，很可能这个查询需要的磁盘临时表，就会占用大量的磁盘空间。</li></ul><p>如何优化 group by 呢?</p><ul><li>group by 后面的字段加索引</li><li>order by null 不用排序</li><li>尽量只使用内存临时表</li><li>使用SQL_BIG_RESULT</li></ul>`,127),o=[i];function c(d,p){return l(),a("div",null,o)}const t=e(n,[["render",c],["__file","轻松搞定SQL调优.html.vue"]]),h=JSON.parse('{"path":"/docs/knowledgeShard/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9ASQL%E8%B0%83%E4%BC%98.html","title":"轻松搞定SQL调优","lang":"zh-CN","frontmatter":{"title":"轻松搞定SQL调优"},"headers":[{"level":2,"title":"1.日常工作怎么进行SQL调优的?","slug":"_1-日常工作怎么进行sql调优的","link":"#_1-日常工作怎么进行sql调优的","children":[]},{"level":2,"title":"2.是否遇到过深分页问题，如何解决","slug":"_2-是否遇到过深分页问题-如何解决","link":"#_2-是否遇到过深分页问题-如何解决","children":[{"level":3,"title":"标签记录法","slug":"标签记录法","link":"#标签记录法","children":[]},{"level":3,"title":"延迟关联法","slug":"延迟关联法","link":"#延迟关联法","children":[]}]},{"level":2,"title":"3.谈谈explain执行计划","slug":"_3-谈谈explain执行计划","link":"#_3-谈谈explain执行计划","children":[{"level":3,"title":"3.1 type","slug":"_3-1-type","link":"#_3-1-type","children":[]},{"level":3,"title":"3.2 rows","slug":"_3-2-rows","link":"#_3-2-rows","children":[]},{"level":3,"title":"3.3 filtered","slug":"_3-3-filtered","link":"#_3-3-filtered","children":[]},{"level":3,"title":"3.4 extra","slug":"_3-4-extra","link":"#_3-4-extra","children":[]},{"level":3,"title":"3.5 key","slug":"_3-5-key","link":"#_3-5-key","children":[]}]},{"level":2,"title":"4.说说大表的优化方案","slug":"_4-说说大表的优化方案","link":"#_4-说说大表的优化方案","children":[{"level":3,"title":"数据库设计优化","slug":"数据库设计优化","link":"#数据库设计优化","children":[]},{"level":3,"title":"索引优化","slug":"索引优化","link":"#索引优化","children":[]},{"level":3,"title":"分区优化","slug":"分区优化","link":"#分区优化","children":[]},{"level":3,"title":"数据清理归档","slug":"数据清理归档","link":"#数据清理归档","children":[]},{"level":3,"title":"缓存优化","slug":"缓存优化","link":"#缓存优化","children":[]},{"level":3,"title":"SQL语句优化","slug":"sql语句优化","link":"#sql语句优化","children":[]},{"level":3,"title":"分库分表","slug":"分库分表","link":"#分库分表","children":[]}]},{"level":2,"title":"5.哪些因素可能导致MySQL慢查询？","slug":"_5-哪些因素可能导致mysql慢查询","link":"#_5-哪些因素可能导致mysql慢查询","children":[]},{"level":2,"title":"6.如何使用索引优化SQL查询？","slug":"_6-如何使用索引优化sql查询","link":"#_6-如何使用索引优化sql查询","children":[]},{"level":2,"title":"7.聊聊慢SQL的优化思路","slug":"_7-聊聊慢sql的优化思路","link":"#_7-聊聊慢sql的优化思路","children":[{"level":3,"title":"7.1 查看慢查询日志记录，分析慢SQL","slug":"_7-1-查看慢查询日志记录-分析慢sql","link":"#_7-1-查看慢查询日志记录-分析慢sql","children":[]},{"level":3,"title":"7.2 explain查看分析SQL的执行计划","slug":"_7-2-explain查看分析sql的执行计划","link":"#_7-2-explain查看分析sql的执行计划","children":[]},{"level":3,"title":"7.3 profile分析执行耗时","slug":"_7-3-profile分析执行耗时","link":"#_7-3-profile分析执行耗时","children":[]},{"level":3,"title":"7.4 Optimizer Trace分析详情","slug":"_7-4-optimizer-trace分析详情","link":"#_7-4-optimizer-trace分析详情","children":[]},{"level":3,"title":"7.5 确定问题并采用相应的措施","slug":"_7-5-确定问题并采用相应的措施","link":"#_7-5-确定问题并采用相应的措施","children":[]}]},{"level":2,"title":"8.一条sql执行过长的时间，你如何优化，从哪些方面入手？","slug":"_8-一条sql执行过长的时间-你如何优化-从哪些方面入手","link":"#_8-一条sql执行过长的时间-你如何优化-从哪些方面入手","children":[{"level":3,"title":"确定瓶颈","slug":"确定瓶颈","link":"#确定瓶颈","children":[]},{"level":3,"title":"索引优化","slug":"索引优化-1","link":"#索引优化-1","children":[]},{"level":3,"title":"优化SQL语句","slug":"优化sql语句","link":"#优化sql语句","children":[]},{"level":3,"title":"数据库参数优化","slug":"数据库参数优化","link":"#数据库参数优化","children":[]},{"level":3,"title":"分析锁的情况","slug":"分析锁的情况","link":"#分析锁的情况","children":[]},{"level":3,"title":"数据库硬件升级","slug":"数据库硬件升级","link":"#数据库硬件升级","children":[]}]},{"level":2,"title":"9.列举一下，常用的数据库设计优化技巧？","slug":"_9-列举一下-常用的数据库设计优化技巧","link":"#_9-列举一下-常用的数据库设计优化技巧","children":[]},{"level":2,"title":"10.列举日常开发中，列举十个书写高质量SQL的小技巧","slug":"_10-列举日常开发中-列举十个书写高质量sql的小技巧","link":"#_10-列举日常开发中-列举十个书写高质量sql的小技巧","children":[]},{"level":2,"title":"11.index merge了解过嘛？","slug":"_11-index-merge了解过嘛","link":"#_11-index-merge了解过嘛","children":[]},{"level":2,"title":"12. order by查询效率慢,如何优化？","slug":"_12-order-by查询效率慢-如何优化","link":"#_12-order-by查询效率慢-如何优化","children":[]},{"level":2,"title":"13. group by 查询慢的话,如何优化?","slug":"_13-group-by-查询慢的话-如何优化","link":"#_13-group-by-查询慢的话-如何优化","children":[]}],"git":{"updatedTime":1715061248000,"contributors":[{"name":"czx","email":"2504058202@qq.com","commits":1}]},"filePathRelative":"docs/knowledgeShard/轻松搞定SQL调优.md"}');export{t as comp,h as data};
