import{_ as e,o as c,c as p,e as o}from"./app-BoIshBAq.js";const a={},s=o('<h1 id="mybatisplus自定义注入器" tabindex="-1"><a class="header-anchor" href="#mybatisplus自定义注入器"><span>mybatisplus自定义注入器</span></a></h1><h2 id="问题与现状" tabindex="-1"><a class="header-anchor" href="#问题与现状"><span>问题与现状</span></a></h2><p>工作中在进行erp相关功能的开发及其他用到sqlserver数据库的时候，使用系统框架mybatisplus的querywrapper写法生成的sql无法自动添加 with (nolock)，这可能产生锁表问题。</p><p>那如何解决这个问题，最简单的方法就是手写sql，那我们都用mybatisplus了肯定不再愿意手写那些sql语句，所以这里用到了mybatisplus提供的注入器</p><h2 id="解决方法实现" tabindex="-1"><a class="header-anchor" href="#解决方法实现"><span>解决方法实现</span></a></h2><div class="custom-container tip"><p class="custom-container-title">我们先讲一下怎么实现的再来解析源码</p></div><h3 id="自定义注入器" tabindex="-1"><a class="header-anchor" href="#自定义注入器"><span>自定义注入器</span></a></h3><p>首先我们创建一个类<code>NolockInjector</code>，并让这个类继承<code>DefaultSqlInjector</code>这个类，然后我们要重写<code>getMethodList()</code>这个方法</p><p><img src="https://czxcab.cn/file/docs/mp1.jpg" alt=""></p><p>result列表中添加的，比如<code>SelectListNolock()</code>就是我们自定义的方法类</p><h3 id="自定义方法" tabindex="-1"><a class="header-anchor" href="#自定义方法"><span>自定义方法</span></a></h3><p>创建一个类<code>SelectListNolock</code>，并继承<code>AbstractMethod</code>这个类，然后重写<code>injectMappedStatement()</code>这个方法，具体怎么写这个方法让它能生成我们想要的sql，等下面具体说明</p><p><img src="https://czxcab.cn/file/docs/mp2.jpg" alt=""></p><h3 id="自定义mapper和serviceimpl" tabindex="-1"><a class="header-anchor" href="#自定义mapper和serviceimpl"><span>自定义Mapper和ServiceImpl</span></a></h3><p>创建一个<code>SqlserverNolockBaseMapper</code>接口和一个<code>SqlServerNolockServiceImpl</code>类，然后将上面自定义的方法写在里面</p><p>SqlserverNolockBaseMapper：</p><p><img src="https://czxcab.cn/file/docs/mp3.jpg" alt=""></p><p>SqlserverNolockBaseMapper：</p><p><img src="https://czxcab.cn/file/docs/mp4.jpg" alt=""></p><h3 id="如何使用" tabindex="-1"><a class="header-anchor" href="#如何使用"><span>如何使用</span></a></h3><p>平时代码中mapper都会继承<code>BaseMapper</code>接口</p><p><img src="https://czxcab.cn/file/docs/mp6.jpg" alt=""></p><p>现在改为继承自定义的<code>SqlserverNolockBaseMapper</code></p><p><img src="https://czxcab.cn/file/docs/mp5.jpg" alt=""></p><p>平时代码中Service都会继承<code>ServiceImpl</code>这个类</p><p><img src="https://czxcab.cn/file/docs/mp7.jpg" alt=""></p><p>现在改为继承自定义的<code>SqlServerNolockServiceImpl</code></p><p><img src="https://czxcab.cn/file/docs/mp8.jpg" alt=""></p><p>然后就能在代码中调用我们自定义的方法了</p><p><img src="https://czxcab.cn/file/docs/mp9.jpg" alt=""></p><h2 id="源码解析" tabindex="-1"><a class="header-anchor" href="#源码解析"><span>源码解析</span></a></h2><h3 id="sql是如何注入的" tabindex="-1"><a class="header-anchor" href="#sql是如何注入的"><span>SQL是如何注入的？</span></a></h3><p>那么SQL到底是如何注入的呢？我们先来看我们继承的SQL注入器，也是mybatisplus默认使用的注入器<code>DefaultSqlInjector</code>，查看一下它的UML图，我们能发现它的最顶层是<code>ISqlInjector</code>接口</p><p><img src="https://czxcab.cn/file/docs/mp10.jpg" alt=""></p><p>进入<code>ISqlInjector</code>接口，我们可以看到一个方法<code>inspectInject()</code>，那么这个接口到底是干嘛用的呢？它只做一件事，那就是检查SQL是否注入，已经注入过则不再注入。</p><p><img src="https://czxcab.cn/file/docs/mp11.jpg" alt=""></p><p>继续往下走，看下一层抽象类<code>AbstractSqlInjector</code>，一共有两个方法。一个是重写后的<code>inspectInject()</code>方法，另一个是<code>inspectInject()</code>方法中调用到的抽象方法<code>getMethodList()</code></p><p><img src="https://czxcab.cn/file/docs/mp12.jpg" alt=""></p><p>我们先来看看<code>getMethodList()</code>方法，可以发现这个方法就是我们自定义注入器所重写的方法，那我们再进入<code>DefaultSqlInjector</code>看一下这个方法做了什么，</p><p><img src="https://czxcab.cn/file/docs/mp13.jpg" alt=""></p><p>从代码可以很清晰的看出，<code>DefaultSqlInjector</code>在这里将MP默认实现的CRUD方法进行注入。</p><p>上面说了一堆，但是我相信你还是没懂，不如一起debug来看看：这里主要看下数据库信息的获取以及方法的注入。</p><p>我们在<code>AbstractSqlInjector</code>中的<code>inspectInject()</code>方法中打个断点，首先我们可以看到<code>TableInfoHelper.initTableInfo()</code>方法获取到了数据库表的相关信息，那么它是如何做到的呢？我们进入刚方法内查看</p><p><img src="https://czxcab.cn/file/docs/mp14.jpg" alt=""></p><p>通过查看代码，我们可以看到初始化数据库信息的方法主要为<code>initTableName()</code>以及<code>initTableFields()</code></p><p><img src="https://czxcab.cn/file/docs/mp15.jpg" alt=""></p><p><code>initTableName()</code>的作用是获取表名信息，主要通过实体上的<code>@TableName</code>注解拿到表名，所以我们这里拿到了表名。</p><p><img src="https://czxcab.cn/file/docs/mp16.jpg" alt=""></p><p><code>initTableFields()</code>的作用主要为获取主键及其他字段信息，至此，数据库信息则获取成功，可供注入SQL方法时使用。</p><p><img src="https://czxcab.cn/file/docs/mp17.jpg" alt=""></p><h3 id="方法注入" tabindex="-1"><a class="header-anchor" href="#方法注入"><span>方法注入</span></a></h3><p>获取完表信息后，可以发现通过<code>getMethodList()</code>方法获取了所有自定义方法，这些方法都是哪里来的呢？都是从<code>AbstractSqlInjector</code>抽象类的子类中获取的，比如默认的SQL注入器<code>DefaultSqlInjector</code>以及我们自定的Inject。</p><p><img src="https://czxcab.cn/file/docs/mp18.jpg" alt=""></p><p>获取所有自定义方法后，可以发现通过调用<code>AbstractMethod</code>的<code>inject()</code>方法实现了SQL的自动注入，这里也把上文获取到的数据库表对象传入用来进行SQL的封装。</p><p><img src="https://czxcab.cn/file/docs/mp19.jpg" alt=""></p><p>可以看到<code>injectMappedStatement()</code>方法就是我们自定义方法中所重写的，根据自己的需求重写方法，最后将生成好的<code>MappedStatement</code>对象加入到全局配置类对象中。</p><p><img src="https://czxcab.cn/file/docs/mp20.jpg" alt=""></p><h3 id="sql语句是怎么生成的" tabindex="-1"><a class="header-anchor" href="#sql语句是怎么生成的"><span>SQL语句是怎么生成的？</span></a></h3><h4 id="abstractmethod" tabindex="-1"><a class="header-anchor" href="#abstractmethod"><span>AbstractMethod</span></a></h4><p>上面了解了SQL是如何注入后，我们再来看下SQL是怎么生成的。我们直接看<code>DefaultSqlInjector</code>提供的默认方法，可以发现所有的方法都继承了<code>AbstractMethod</code>。该类主要用于封装Mapper接口中定义的方法信息，并提供了一些默认实现。通过继承<code>AbstractMethod</code>类并重写其中的方法，我们可以自定义生成 SQL 语句的方式，从而实现更加灵活的 SQL 操作。</p><p>该类我们目前只需要关注<code>inject()</code>方法，它主要通过<code>injectMappedStatement()</code>方法实现了自动注入SQL的动作。<code>injectMappedStatement()</code>是一个模板方法，每个自定义SQL类都可以对其进行重写，然后将封装好的sql存放到全局配置文件类中。</p><p>这里我们以<code>SelectById</code>类作为案例来对其分析。</p><p>首先可以看到在构造方法中将<code>SqlMethod</code>枚举类中定义好的方法名传入到父类中，方便后续使用；同时重写<code>injectMappedStatement()</code>方法，通过SQL模板构建出SQL语句并存入到全局配置类中。</p><p><img src="https://czxcab.cn/file/docs/mp21.jpg" alt=""></p><h4 id="sqlmethod" tabindex="-1"><a class="header-anchor" href="#sqlmethod"><span>SqlMethod</span></a></h4><p><img src="https://czxcab.cn/file/docs/mp22.jpg" alt=""></p><p><code>SqlMethod</code>就是一个枚举类，存储了两个关键的元素：</p><ul><li><code>BaseMapper</code>中的方法名</li><li>方法名对应的sql语句模板 看到这两个元素，相信大家应该已经知道SQL自动生成的本质了：根据不同的方法来提供一些通用的模板，项目启动后再将其加载进<code>mappedStatement</code>。</li></ul><h4 id="sqlsource" tabindex="-1"><a class="header-anchor" href="#sqlsource"><span>SqlSource</span></a></h4><p><code>SqlSource</code>对象里面则是通过解析SQL模板、以及传入的表信息和主键信息构建出了一条SQL语句：</p><p><img src="https://czxcab.cn/file/docs/mp23.jpg" alt=""></p><p>可能会有人疑惑这里的表信息是从何而来，其实这些表信息就是在SQL注入的时候获取的表信息，然后传到<code>AbstractMethod</code>中的，所以在重写<code>injectMappedStatement()</code>方法的时候就可以使用到了。</p><p><img src="https://czxcab.cn/file/docs/mp24.jpg" alt=""></p><h3 id="mapper文件被添加的过程" tabindex="-1"><a class="header-anchor" href="#mapper文件被添加的过程"><span>Mapper文件被添加的过程</span></a></h3><p>看完上述内容相信大家应该都知道了SQL注入器的基本原理了，那么SQL注入器是在哪里添加到Mybatis中的呢？如果不太清楚的话，我们带着问题往下看。</p><p>首先我们回顾下Mybatis 的执行流程，一般可以分为以下几个步骤：</p><ol><li>加载配置文件：在应用启动时，Mybatis 会读取配置文件<code>mybatis-config.xml</code>并解析其中的配置信息，例如数据库连接信息、映射器信息等。</li><li>创建 <code>SqlSessionFactory</code>：通过<code>SqlSessionFactoryBuilder</code> 类加载配置文件中的信息，并创建 <code>SqlSessionFactory</code> 对象。<code>SqlSessionFactory</code> 是一个重量级的对象，它的作用是创建 <code>SqlSession</code> 对象，<code>SqlSession</code> 是用于执行 SQL 语句的核心对象。</li><li>创建 <code>SqlSession</code>：通过 <code>SqlSessionFactory</code> 的 <code>openSession</code> 方法创建 <code>SqlSession</code> 对象。在执行 SQL 操作时，我们需要通过 SqlSession 对象获取到对应的 Mapper 接口，然后调用该接口中定义的方法来执行 SQL 语句。</li><li>获取 <code>Mapper</code> 接口：在 Mybatis 中，我们通常通过 <code>Mapper</code> 接口的方式执行 SQL 操作。因此，在获取 <code>Mapper</code> 接口之前，我们需要先配置映射关系，即在配置文件中指定 <code>Mapper</code> 接口所对应的 XML 文件或注解类。在创建 <code>SqlSession</code> 对象后，我们可以通过 <code>SqlSession</code> 的 <code>getMapper</code> 方法获取到对应的 <code>Mapper</code> 接口。</li><li>执行 SQL 语句：当我们获取到 <code>Mapper</code> 接口后，就可以通过调用其方法执行 SQL 语句了。在执行 SQL 语句前，Mybatis 会将 <code>Mapper</code> 接口中定义的 SQL 语句转换成 <code>MappedStatement</code> 对象，并将其中的参数信息传递给 <code>Executor</code> 对象执行 SQL 语句。</li><li>处理 SQL 语句的执行结果：在执行 SQL 语句后，Mybatis 会将查询结果封装成对应的 Java 对象并返回。</li></ol><p><img src="https://czxcab.cn/file/docs/mp25.jpg" alt=""></p><h3 id="mp入口" tabindex="-1"><a class="header-anchor" href="#mp入口"><span>MP入口</span></a></h3><p>可能有些人不知道MP的具体入口从哪里看，其实很简单，我们可以直接去<code>mybatis-plus-boot-starter</code>中<code>resources</code>下的<code>META-INF</code>文件夹下查看：</p><p><img src="https://czxcab.cn/file/docs/mp26.jpg" alt=""></p><p>可以看到配置的自动启动类是<code>MybatisPlusAutoConfiguration</code>；</p><p>这个类由于实现了<code>InitializingBean</code>接口，得到了<code>afterPropertiesSet</code>方法，在Bean初始化后，会自动调用。 还有三个标注了 <code>@ConditionalOnMissingBean</code> 注解的方法，说明这些方法在没有配置对应对象时会由SpringBoot创建Bean，并且保存到容器中。</p><p>所以<code>sqlSessionFactory</code>方法在没有配置<code>SqlSessionFactory</code>时会由SpringBoot创建Bean，并且保存到容器中。</p><h3 id="mybatissqlsessionfactorybean" tabindex="-1"><a class="header-anchor" href="#mybatissqlsessionfactorybean"><span>MybatisSqlSessionFactoryBean</span></a></h3><p>我们可以发现进入<code>sqlSessionFactory</code>方法后就会实例化<code>MybatisSqlSessionFactoryBean</code>类，那么该类到底做了什么呢？</p><p><img src="https://czxcab.cn/file/docs/mp27.jpg" alt=""></p><p>可以发现该类实现了三个接口<code>FactoryBean&lt;SqlSessionFactory&gt;</code>, <code>InitializingBean</code>, <code>ApplicationListener&lt;ApplicationEvent&gt;</code>：</p><ol><li><p><code>FactoryBean</code>：说明用到了工厂模式</p></li><li><p><code>InitializingBean</code>：<code>afterPropertiesSet</code> 在属性设置完成时调用（在Bean创建完成时）调用</p></li><li><p><code>ApplicationListener</code>是一个监听器，监听的是<code>ApplicationContext</code>初始化或者刷新事件，当初始化或者刷新时调用。</p></li></ol><p>这里我们主要看初始化后调用的方法<code>afterPropertiesSet</code>：可以发现在该方法中调用了<code>buildSqlSessionFactory</code>方法。</p><p><img src="https://czxcab.cn/file/docs/mp28.jpg" alt=""></p><h3 id="buildsqlsessionfactory" tabindex="-1"><a class="header-anchor" href="#buildsqlsessionfactory"><span>buildSqlSessionFactory</span></a></h3><p>那么<code>buildSqlSessionFactory</code>方法做了些什么呢？简单的说就是创建一个<code>SqlSessionFactory</code>实例，虽然里面还有很多其他步骤，但是不在本文谈论范围内。</p><p>我们直接看最重要的部分<code>xmlMapperBuilder.parse()</code>：</p><p><img src="https://czxcab.cn/file/docs/mp29.jpg" alt=""></p><p><code>parse</code>方法主要用来解析xml文件，<code>bindMapperForNamespace</code>方法则用来解析接口文件。</p><p><img src="https://czxcab.cn/file/docs/mp30.jpg" alt=""></p><p><code>addMapper</code>方法是由前面<code>MybatisConfiguration</code>调用的。</p><p><img src="https://czxcab.cn/file/docs/mp31.jpg" alt=""></p><p>我们进入<code>MybatisConfiguration</code>这里会解析出对应的类型，然后内部调用<code>MybatisMapperRegistry</code>的方法：</p><p><img src="https://czxcab.cn/file/docs/mp32.jpg" alt=""></p><p>内部最后是由<code>MybatisMapperAnnotationBuilder</code>去解析的：</p><p><img src="https://czxcab.cn/file/docs/mp33.jpg" alt=""></p><p>可以发现最后又回到了我们最初说到的<code>AbstractSqlInjector</code>类中的<code>inspectInject</code>方法，该类帮助我们实现了基本SQL方法的自动注入。</p><p><img src="https://czxcab.cn/file/docs/mp34.jpg" alt=""></p><p>到这里相信大家已经对SQL注入器的原理有了一个清楚的认识了，如果还不太理解的话，可以从MP入口处开始，根据截图的内容自行打断点熟悉下。</p>',106),t=[s];function d(l,i){return c(),p("div",null,t)}const r=e(a,[["render",d],["__file","mybatisplus自定义注入器.html.vue"]]),h=JSON.parse('{"path":"/docs/knowledgeShard/mybatisplus%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E5%85%A5%E5%99%A8.html","title":"mybatisplus自定义注入器","lang":"zh-CN","frontmatter":{"title":"mybatisplus自定义注入器"},"headers":[{"level":2,"title":"问题与现状","slug":"问题与现状","link":"#问题与现状","children":[]},{"level":2,"title":"解决方法实现","slug":"解决方法实现","link":"#解决方法实现","children":[{"level":3,"title":"自定义注入器","slug":"自定义注入器","link":"#自定义注入器","children":[]},{"level":3,"title":"自定义方法","slug":"自定义方法","link":"#自定义方法","children":[]},{"level":3,"title":"自定义Mapper和ServiceImpl","slug":"自定义mapper和serviceimpl","link":"#自定义mapper和serviceimpl","children":[]},{"level":3,"title":"如何使用","slug":"如何使用","link":"#如何使用","children":[]}]},{"level":2,"title":"源码解析","slug":"源码解析","link":"#源码解析","children":[{"level":3,"title":"SQL是如何注入的？","slug":"sql是如何注入的","link":"#sql是如何注入的","children":[]},{"level":3,"title":"方法注入","slug":"方法注入","link":"#方法注入","children":[]},{"level":3,"title":"SQL语句是怎么生成的？","slug":"sql语句是怎么生成的","link":"#sql语句是怎么生成的","children":[]},{"level":3,"title":"Mapper文件被添加的过程","slug":"mapper文件被添加的过程","link":"#mapper文件被添加的过程","children":[]},{"level":3,"title":"MP入口","slug":"mp入口","link":"#mp入口","children":[]},{"level":3,"title":"MybatisSqlSessionFactoryBean","slug":"mybatissqlsessionfactorybean","link":"#mybatissqlsessionfactorybean","children":[]},{"level":3,"title":"buildSqlSessionFactory","slug":"buildsqlsessionfactory","link":"#buildsqlsessionfactory","children":[]}]}],"git":{"updatedTime":1704359960000,"contributors":[{"name":"czx","email":"2504058202@qq.com","commits":2}]},"filePathRelative":"docs/knowledgeShard/mybatisplus自定义注入器.md"}');export{r as comp,h as data};
